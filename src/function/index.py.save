import json
import boto3
from ydb import SessionPool, driver
import urllib.request
import uuid
from datetime import datetime
import os

# Configuration from environment variables
BUCKET_NAME = os.environ['BUCKET_NAME']
YDB_ENDPOINT = os.environ['YDB_ENDPOINT']
YDB_DATABASE = os.environ['YDB_DATABASE']
QUEUE_URL = os.environ['QUEUE_URL']

# Initialize YDB client
try:
    driver_config = driver.DriverConfig(
        YDB_ENDPOINT,
        YDB_DATABASE,
        credentials=driver.iam_metadata_credentials()
    )
    pool = SessionPool(driver.Driver(driver_config))
except Exception as e:
    print(f"YDB initialization error: {e}")
    pool = None

def handler(event, context):
    """
    Handles two types of requests:
    1. Async document processing from Message Queue
    2. Sync document list requests from API Gateway
    """
    
    print(f"Received event: {json.dumps(event, indent=2)}")
    
    # Check if this is a Message Queue event
    if 'messages' in event:
        return process_document(event)
    else:
        return get_documents_list(event)

def process_document(event):
    """Process document upload from Message Queue"""
    try:
        message = event['messages'][0]
        body = json.loads(message['details']['message']['body'])
        
        name = body['name']
        url = body['url']
        
        print(f"Processing document: {name} from {url}")
        
        # 1. Download file
        response = urllib.request.urlopen(url)
        file_content = response.read()
        print(f"Downloaded {len(file_content)} bytes")
        
        # 2. Save to Storage
        s3 = boto3.client(
            's3',
            endpoint_url='https://storage.yandexcloud.net',
            aws_access_key_id=os.environ['AWS_ACCESS_KEY_ID'],
            aws_secret_access_key=os.environ['AWS_SECRET_ACCESS_KEY']
        )
        
        file_key = f"doc_{uuid.uuid4()}_{name}"
        s3.put_object(
            Bucket=BUCKET_NAME,
            Key=file_key,
            Body=file_content,
            ContentType='application/pdf'
        )
        print(f"Saved to storage: {file_key}")
        
        # 3. Save metadata to YDB
        if pool:
            with pool.checkout() as session:
                query = """
                UPSERT INTO documents (id, name, key, original_url, created_at, size)
                VALUES (?, ?, ?, ?, ?, ?)
                """
                session.transaction().execute(
                    query,
                    parameters={
                        'id': str(uuid.uuid4()),
                        'name': name,
                        'key': file_key,
                        'original_url': url,
                        'created_at': datetime.utcnow(),
                        'size': len(file_content)
                    },
                    commit_tx=True
                )
            print("Saved metadata to YDB")
        else:
            print("YDB not available, skipping metadata save")
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'status': 'processed',
                'key': file_key,
                'size': len(file_content)
            })
        }
        
    except Exception as e:
        print(f"Error processing document: {e}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)})
        }

def get_documents_list(event):
    """Return list of documents from YDB"""
    try:
        print("Getting document list from YDB")
        
        if not pool:
            return {
                'statusCode': 500,
                'body': json.dumps({'error': 'YDB not initialized'}),
                'headers': {'Content-Type': 'application/json'}
            }
        
        with pool.checkout() as session:
            # Query YDB
            result = session.transaction().execute(
                "SELECT id, name, key, original_url, created_at, size FROM documents ORDER BY created_at DESC",
                commit_tx=True
            )
            
            # Convert to JSON
            documents = []
            for row in result[0].rows:
                documents.append({
                    'id': row.id.decode('utf-8') if isinstance(row.id, bytes) else row.id,
                    'name': row.name.decode('utf-8') if isinstance(row.name, bytes) else row.name,
                    'key': row.key.decode('utf-8') if isinstance(row.key, bytes) else row.key,
                    'original_url': row.original_url.decode('utf-8') if isinstance(row.original_url, bytes) else row.original_url,
                    'created_at': row.created_at.isoformat() if hasattr(row.created_at, 'isoformat') else str(row.created_at),
                    'size': int(row.size) if row.size else 0
                })
            
            print(f"Found {len(documents)} documents")
            
            return {
                'statusCode': 200,
                'body': json.dumps(documents, default=str),
                'headers': {
                    'Content-Type': 'application/json'
                }
            }
            
    except Exception as e:
        print(f"Error getting documents: {e}")
        return {
            'statusCode': 500,
            'body': json.dumps({'error': str(e)}),
            'headers': {
                'Content-Type': 'application/json'
            }
        }import json
import os

def handler(event, context):
    """
    Minimal handler for testing - NO external dependencies
    """
    print(f"Event received: {json.dumps(event, indent=2)}")
    
    # Extract message if from queue trigger
    messages = event.get('messages', [])
    if messages:
        for msg in messages:
            body = msg.get('details', {}).get('message', {}).get('body', '{}')
            print(f"Message body: {body}")
    
    return {
        'statusCode': 200,
        'body': json.dumps({
            'message': 'Function is working!',
            'student': os.environ.get('STUDENT_NAME', 'Факи Доосууур Дорис'),
            'student_prefix': os.environ.get('STUDENT_PREFIX', 'faki'),
            'bucket': os.environ.get('BUCKET_NAME', 'unknown'),
            'queue': os.environ.get('QUEUE_URL', 'unknown'),
            'ydb': os.environ.get('YDB_DATABASE', 'unknown')
        })
    }
